// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace comm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class SigninRequest;
class SigninReply;
class CreateSessionRequest;
class CreateSessionReply;
class JoinSessionRequest;
class JoinSessionReply;
class JoinSessionReply_Player;
class ListSessionRequest;
class ListSessionReply;
class ListSessionReply_Session;
class LeaveSessionRequest;
class LeaveSessionReply;

enum Service {
  CREATE_SESSION = 100,
  JOIN_SESSION = 101,
  LEAVE_SESSION = 102,
  START_GAME = 103,
  END_GAME = 104,
  TTT_MOVE = 200
};
bool Service_IsValid(int value);
const Service Service_MIN = CREATE_SESSION;
const Service Service_MAX = TTT_MOVE;
const int Service_ARRAYSIZE = Service_MAX + 1;

const ::google::protobuf::EnumDescriptor* Service_descriptor();
inline const ::std::string& Service_Name(Service value) {
  return ::google::protobuf::internal::NameOfEnum(
    Service_descriptor(), value);
}
inline bool Service_Parse(
    const ::std::string& name, Service* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Service>(
    Service_descriptor(), name, value);
}
enum Error {
  OK = 0,
  INVALID_REQUEST = 2
};
bool Error_IsValid(int value);
const Error Error_MIN = OK;
const Error Error_MAX = INVALID_REQUEST;
const int Error_ARRAYSIZE = Error_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_descriptor();
inline const ::std::string& Error_Name(Error value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_descriptor(), value);
}
inline bool Error_Parse(
    const ::std::string& name, Error* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error>(
    Error_descriptor(), name, value);
}
enum Game {
  TICTACTOE = 1
};
bool Game_IsValid(int value);
const Game Game_MIN = TICTACTOE;
const Game Game_MAX = TICTACTOE;
const int Game_ARRAYSIZE = Game_MAX + 1;

const ::google::protobuf::EnumDescriptor* Game_descriptor();
inline const ::std::string& Game_Name(Game value) {
  return ::google::protobuf::internal::NameOfEnum(
    Game_descriptor(), value);
}
inline bool Game_Parse(
    const ::std::string& name, Game* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Game>(
    Game_descriptor(), name, value);
}
// ===================================================================

class SigninRequest : public ::google::protobuf::Message {
 public:
  SigninRequest();
  virtual ~SigninRequest();

  SigninRequest(const SigninRequest& from);

  inline SigninRequest& operator=(const SigninRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SigninRequest& default_instance();

  void Swap(SigninRequest* other);

  // implements Message ----------------------------------------------

  SigninRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SigninRequest& from);
  void MergeFrom(const SigninRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:comm.SigninRequest)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static SigninRequest* default_instance_;
};
// -------------------------------------------------------------------

class SigninReply : public ::google::protobuf::Message {
 public:
  SigninReply();
  virtual ~SigninReply();

  SigninReply(const SigninReply& from);

  inline SigninReply& operator=(const SigninReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SigninReply& default_instance();

  void Swap(SigninReply* other);

  // implements Message ----------------------------------------------

  SigninReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SigninReply& from);
  void MergeFrom(const SigninReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:comm.SigninReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static SigninReply* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionRequest : public ::google::protobuf::Message {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  void Swap(CreateSessionRequest* other);

  // implements Message ----------------------------------------------

  CreateSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required int32 game = 2;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 2;
  inline ::google::protobuf::int32 game() const;
  inline void set_game(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comm.CreateSessionRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_game();
  inline void clear_has_game();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::int32 game_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionReply : public ::google::protobuf::Message {
 public:
  CreateSessionReply();
  virtual ~CreateSessionReply();

  CreateSessionReply(const CreateSessionReply& from);

  inline CreateSessionReply& operator=(const CreateSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionReply& default_instance();

  void Swap(CreateSessionReply* other);

  // implements Message ----------------------------------------------

  CreateSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionReply& from);
  void MergeFrom(const CreateSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // required string host = 3;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 3;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required int32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comm.CreateSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 port_;
  ::std::string* host_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionRequest : public ::google::protobuf::Message {
 public:
  JoinSessionRequest();
  virtual ~JoinSessionRequest();

  JoinSessionRequest(const JoinSessionRequest& from);

  inline JoinSessionRequest& operator=(const JoinSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionRequest& default_instance();

  void Swap(JoinSessionRequest* other);

  // implements Message ----------------------------------------------

  JoinSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionRequest& from);
  void MergeFrom(const JoinSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // @@protoc_insertion_point(class_scope:comm.JoinSessionRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionReply_Player : public ::google::protobuf::Message {
 public:
  JoinSessionReply_Player();
  virtual ~JoinSessionReply_Player();

  JoinSessionReply_Player(const JoinSessionReply_Player& from);

  inline JoinSessionReply_Player& operator=(const JoinSessionReply_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionReply_Player& default_instance();

  void Swap(JoinSessionReply_Player* other);

  // implements Message ----------------------------------------------

  JoinSessionReply_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionReply_Player& from);
  void MergeFrom(const JoinSessionReply_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string avatar = 3;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:comm.JoinSessionReply.Player)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionReply_Player* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionReply : public ::google::protobuf::Message {
 public:
  JoinSessionReply();
  virtual ~JoinSessionReply();

  JoinSessionReply(const JoinSessionReply& from);

  inline JoinSessionReply& operator=(const JoinSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionReply& default_instance();

  void Swap(JoinSessionReply* other);

  // implements Message ----------------------------------------------

  JoinSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionReply& from);
  void MergeFrom(const JoinSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JoinSessionReply_Player Player;

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated group Player = 3 {
  inline int player_size() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 3;
  inline const ::comm::JoinSessionReply_Player& player(int index) const;
  inline ::comm::JoinSessionReply_Player* mutable_player(int index);
  inline ::comm::JoinSessionReply_Player* add_player();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >&
      player() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >*
      mutable_player();

  // @@protoc_insertion_point(class_scope:comm.JoinSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player > player_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionRequest : public ::google::protobuf::Message {
 public:
  ListSessionRequest();
  virtual ~ListSessionRequest();

  ListSessionRequest(const ListSessionRequest& from);

  inline ListSessionRequest& operator=(const ListSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionRequest& default_instance();

  void Swap(ListSessionRequest* other);

  // implements Message ----------------------------------------------

  ListSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionRequest& from);
  void MergeFrom(const ListSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:comm.ListSessionRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionReply_Session : public ::google::protobuf::Message {
 public:
  ListSessionReply_Session();
  virtual ~ListSessionReply_Session();

  ListSessionReply_Session(const ListSessionReply_Session& from);

  inline ListSessionReply_Session& operator=(const ListSessionReply_Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionReply_Session& default_instance();

  void Swap(ListSessionReply_Session* other);

  // implements Message ----------------------------------------------

  ListSessionReply_Session* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionReply_Session& from);
  void MergeFrom(const ListSessionReply_Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string creator_id = 1;
  inline bool has_creator_id() const;
  inline void clear_creator_id();
  static const int kCreatorIdFieldNumber = 1;
  inline const ::std::string& creator_id() const;
  inline void set_creator_id(const ::std::string& value);
  inline void set_creator_id(const char* value);
  inline void set_creator_id(const char* value, size_t size);
  inline ::std::string* mutable_creator_id();
  inline ::std::string* release_creator_id();
  inline void set_allocated_creator_id(::std::string* creator_id);

  // required string creator_name = 5;
  inline bool has_creator_name() const;
  inline void clear_creator_name();
  static const int kCreatorNameFieldNumber = 5;
  inline const ::std::string& creator_name() const;
  inline void set_creator_name(const ::std::string& value);
  inline void set_creator_name(const char* value);
  inline void set_creator_name(const char* value, size_t size);
  inline ::std::string* mutable_creator_name();
  inline ::std::string* release_creator_name();
  inline void set_allocated_creator_name(::std::string* creator_name);

  // required string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // required int32 player_count = 4;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 4;
  inline ::google::protobuf::int32 player_count() const;
  inline void set_player_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comm.ListSessionReply.Session)
 private:
  inline void set_has_creator_id();
  inline void clear_has_creator_id();
  inline void set_has_creator_name();
  inline void clear_has_creator_name();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* creator_id_;
  ::std::string* creator_name_;
  ::std::string* host_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 player_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionReply_Session* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionReply : public ::google::protobuf::Message {
 public:
  ListSessionReply();
  virtual ~ListSessionReply();

  ListSessionReply(const ListSessionReply& from);

  inline ListSessionReply& operator=(const ListSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionReply& default_instance();

  void Swap(ListSessionReply* other);

  // implements Message ----------------------------------------------

  ListSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionReply& from);
  void MergeFrom(const ListSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ListSessionReply_Session Session;

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated group Session = 2 {
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::comm::ListSessionReply_Session& session(int index) const;
  inline ::comm::ListSessionReply_Session* mutable_session(int index);
  inline ::comm::ListSessionReply_Session* add_session();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >&
      session() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >*
      mutable_session();

  // @@protoc_insertion_point(class_scope:comm.ListSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session > session_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class LeaveSessionRequest : public ::google::protobuf::Message {
 public:
  LeaveSessionRequest();
  virtual ~LeaveSessionRequest();

  LeaveSessionRequest(const LeaveSessionRequest& from);

  inline LeaveSessionRequest& operator=(const LeaveSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveSessionRequest& default_instance();

  void Swap(LeaveSessionRequest* other);

  // implements Message ----------------------------------------------

  LeaveSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveSessionRequest& from);
  void MergeFrom(const LeaveSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:comm.LeaveSessionRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaveSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveSessionReply : public ::google::protobuf::Message {
 public:
  LeaveSessionReply();
  virtual ~LeaveSessionReply();

  LeaveSessionReply(const LeaveSessionReply& from);

  inline LeaveSessionReply& operator=(const LeaveSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveSessionReply& default_instance();

  void Swap(LeaveSessionReply* other);

  // implements Message ----------------------------------------------

  LeaveSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveSessionReply& from);
  void MergeFrom(const LeaveSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comm.LeaveSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaveSessionReply* default_instance_;
};
// ===================================================================


// ===================================================================

// SigninRequest

// required string uid = 1;
inline bool SigninRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninRequest::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SigninRequest::uid() const {
  return *uid_;
}
inline void SigninRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SigninRequest::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SigninRequest::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninRequest::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SigninRequest::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninRequest::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool SigninRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SigninRequest::password() const {
  return *password_;
}
inline void SigninRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SigninRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SigninRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SigninRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SigninReply

// required int32 type = 1;
inline bool SigninReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SigninReply::type() const {
  return type_;
}
inline void SigninReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string token = 2;
inline bool SigninReply::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninReply::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninReply::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninReply::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& SigninReply::token() const {
  return *token_;
}
inline void SigninReply::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SigninReply::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void SigninReply::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninReply::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* SigninReply::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninReply::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateSessionRequest

// required string token = 1;
inline bool CreateSessionRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CreateSessionRequest::token() const {
  return *token_;
}
inline void CreateSessionRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CreateSessionRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CreateSessionRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CreateSessionRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 game = 2;
inline bool CreateSessionRequest::has_game() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionRequest::set_has_game() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionRequest::clear_has_game() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionRequest::clear_game() {
  game_ = 0;
  clear_has_game();
}
inline ::google::protobuf::int32 CreateSessionRequest::game() const {
  return game_;
}
inline void CreateSessionRequest::set_game(::google::protobuf::int32 value) {
  set_has_game();
  game_ = value;
}

// -------------------------------------------------------------------

// CreateSessionReply

// required int32 type = 1;
inline bool CreateSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CreateSessionReply::type() const {
  return type_;
}
inline void CreateSessionReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string sid = 2;
inline bool CreateSessionReply::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionReply::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionReply::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionReply::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& CreateSessionReply::sid() const {
  return *sid_;
}
inline void CreateSessionReply::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void CreateSessionReply::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void CreateSessionReply::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionReply::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* CreateSessionReply::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionReply::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string host = 3;
inline bool CreateSessionReply::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSessionReply::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSessionReply::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSessionReply::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& CreateSessionReply::host() const {
  return *host_;
}
inline void CreateSessionReply::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CreateSessionReply::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CreateSessionReply::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionReply::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* CreateSessionReply::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionReply::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 4;
inline bool CreateSessionReply::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSessionReply::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSessionReply::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSessionReply::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 CreateSessionReply::port() const {
  return port_;
}
inline void CreateSessionReply::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// JoinSessionRequest

// required string token = 1;
inline bool JoinSessionRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& JoinSessionRequest::token() const {
  return *token_;
}
inline void JoinSessionRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void JoinSessionRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void JoinSessionRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* JoinSessionRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sid = 2;
inline bool JoinSessionRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinSessionRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinSessionRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinSessionRequest::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& JoinSessionRequest::sid() const {
  return *sid_;
}
inline void JoinSessionRequest::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void JoinSessionRequest::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void JoinSessionRequest::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionRequest::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* JoinSessionRequest::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionRequest::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// JoinSessionReply_Player

// required bytes uid = 1;
inline bool JoinSessionReply_Player::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionReply_Player::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionReply_Player::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionReply_Player::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& JoinSessionReply_Player::uid() const {
  return *uid_;
}
inline void JoinSessionReply_Player::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void JoinSessionReply_Player::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void JoinSessionReply_Player::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* JoinSessionReply_Player::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool JoinSessionReply_Player::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinSessionReply_Player::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinSessionReply_Player::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinSessionReply_Player::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JoinSessionReply_Player::name() const {
  return *name_;
}
inline void JoinSessionReply_Player::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply_Player::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply_Player::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* JoinSessionReply_Player::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string avatar = 3;
inline bool JoinSessionReply_Player::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinSessionReply_Player::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinSessionReply_Player::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinSessionReply_Player::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& JoinSessionReply_Player::avatar() const {
  return *avatar_;
}
inline void JoinSessionReply_Player::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void JoinSessionReply_Player::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void JoinSessionReply_Player::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* JoinSessionReply_Player::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// JoinSessionReply

// required int32 type = 1;
inline bool JoinSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 JoinSessionReply::type() const {
  return type_;
}
inline void JoinSessionReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated group Player = 3 {
inline int JoinSessionReply::player_size() const {
  return player_.size();
}
inline void JoinSessionReply::clear_player() {
  player_.Clear();
}
inline const ::comm::JoinSessionReply_Player& JoinSessionReply::player(int index) const {
  return player_.Get(index);
}
inline ::comm::JoinSessionReply_Player* JoinSessionReply::mutable_player(int index) {
  return player_.Mutable(index);
}
inline ::comm::JoinSessionReply_Player* JoinSessionReply::add_player() {
  return player_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >&
JoinSessionReply::player() const {
  return player_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >*
JoinSessionReply::mutable_player() {
  return &player_;
}

// -------------------------------------------------------------------

// ListSessionRequest

// required string token = 1;
inline bool ListSessionRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionRequest::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ListSessionRequest::token() const {
  return *token_;
}
inline void ListSessionRequest::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ListSessionRequest::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ListSessionRequest::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionRequest::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ListSessionRequest::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionRequest::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 count = 2;
inline bool ListSessionRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSessionRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSessionRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSessionRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ListSessionRequest::count() const {
  return count_;
}
inline void ListSessionRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ListSessionReply_Session

// required string creator_id = 1;
inline bool ListSessionReply_Session::has_creator_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionReply_Session::set_has_creator_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionReply_Session::clear_has_creator_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionReply_Session::clear_creator_id() {
  if (creator_id_ != &::google::protobuf::internal::kEmptyString) {
    creator_id_->clear();
  }
  clear_has_creator_id();
}
inline const ::std::string& ListSessionReply_Session::creator_id() const {
  return *creator_id_;
}
inline void ListSessionReply_Session::set_creator_id(const ::std::string& value) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(value);
}
inline void ListSessionReply_Session::set_creator_id(const char* value) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(value);
}
inline void ListSessionReply_Session::set_creator_id(const char* value, size_t size) {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  creator_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionReply_Session::mutable_creator_id() {
  set_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    creator_id_ = new ::std::string;
  }
  return creator_id_;
}
inline ::std::string* ListSessionReply_Session::release_creator_id() {
  clear_has_creator_id();
  if (creator_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_id_;
    creator_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionReply_Session::set_allocated_creator_id(::std::string* creator_id) {
  if (creator_id_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_id_;
  }
  if (creator_id) {
    set_has_creator_id();
    creator_id_ = creator_id;
  } else {
    clear_has_creator_id();
    creator_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string creator_name = 5;
inline bool ListSessionReply_Session::has_creator_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSessionReply_Session::set_has_creator_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSessionReply_Session::clear_has_creator_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSessionReply_Session::clear_creator_name() {
  if (creator_name_ != &::google::protobuf::internal::kEmptyString) {
    creator_name_->clear();
  }
  clear_has_creator_name();
}
inline const ::std::string& ListSessionReply_Session::creator_name() const {
  return *creator_name_;
}
inline void ListSessionReply_Session::set_creator_name(const ::std::string& value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
}
inline void ListSessionReply_Session::set_creator_name(const char* value) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(value);
}
inline void ListSessionReply_Session::set_creator_name(const char* value, size_t size) {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  creator_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionReply_Session::mutable_creator_name() {
  set_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    creator_name_ = new ::std::string;
  }
  return creator_name_;
}
inline ::std::string* ListSessionReply_Session::release_creator_name() {
  clear_has_creator_name();
  if (creator_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = creator_name_;
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionReply_Session::set_allocated_creator_name(::std::string* creator_name) {
  if (creator_name_ != &::google::protobuf::internal::kEmptyString) {
    delete creator_name_;
  }
  if (creator_name) {
    set_has_creator_name();
    creator_name_ = creator_name;
  } else {
    clear_has_creator_name();
    creator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string host = 2;
inline bool ListSessionReply_Session::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListSessionReply_Session::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListSessionReply_Session::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListSessionReply_Session::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ListSessionReply_Session::host() const {
  return *host_;
}
inline void ListSessionReply_Session::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ListSessionReply_Session::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ListSessionReply_Session::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionReply_Session::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* ListSessionReply_Session::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionReply_Session::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 port = 3;
inline bool ListSessionReply_Session::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListSessionReply_Session::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListSessionReply_Session::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListSessionReply_Session::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ListSessionReply_Session::port() const {
  return port_;
}
inline void ListSessionReply_Session::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required int32 player_count = 4;
inline bool ListSessionReply_Session::has_player_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListSessionReply_Session::set_has_player_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListSessionReply_Session::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListSessionReply_Session::clear_player_count() {
  player_count_ = 0;
  clear_has_player_count();
}
inline ::google::protobuf::int32 ListSessionReply_Session::player_count() const {
  return player_count_;
}
inline void ListSessionReply_Session::set_player_count(::google::protobuf::int32 value) {
  set_has_player_count();
  player_count_ = value;
}

// -------------------------------------------------------------------

// ListSessionReply

// required int32 type = 1;
inline bool ListSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ListSessionReply::type() const {
  return type_;
}
inline void ListSessionReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated group Session = 2 {
inline int ListSessionReply::session_size() const {
  return session_.size();
}
inline void ListSessionReply::clear_session() {
  session_.Clear();
}
inline const ::comm::ListSessionReply_Session& ListSessionReply::session(int index) const {
  return session_.Get(index);
}
inline ::comm::ListSessionReply_Session* ListSessionReply::mutable_session(int index) {
  return session_.Mutable(index);
}
inline ::comm::ListSessionReply_Session* ListSessionReply::add_session() {
  return session_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >&
ListSessionReply::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >*
ListSessionReply::mutable_session() {
  return &session_;
}

// -------------------------------------------------------------------

// LeaveSessionRequest

// -------------------------------------------------------------------

// LeaveSessionReply

// required int32 type = 1;
inline bool LeaveSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveSessionReply::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LeaveSessionReply::type() const {
  return type_;
}
inline void LeaveSessionReply::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comm::Service>() {
  return ::comm::Service_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comm::Error>() {
  return ::comm::Error_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comm::Game>() {
  return ::comm::Game_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
