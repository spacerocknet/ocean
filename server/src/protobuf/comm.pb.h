// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace comm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class Service;
class Error;
class HelloRequest;
class HelloReply;
class PingpongRequest;
class PingpongReply;
class SigninRequest;
class SigninReply;
class CreateSessionRequest;
class CreateSessionReply;
class JoinSessionRequest;
class JoinSessionReply;
class JoinSessionReply_Player;
class ListSessionRequest;
class ListSessionReply;
class ListSessionReply_Session;
class LeaveSessionRequest;
class LeaveSessionReply;

enum Service_Type {
  Service_Type_HELLO = 1,
  Service_Type_PINGPONG = 2
};
bool Service_Type_IsValid(int value);
const Service_Type Service_Type_Type_MIN = Service_Type_HELLO;
const Service_Type Service_Type_Type_MAX = Service_Type_PINGPONG;
const int Service_Type_Type_ARRAYSIZE = Service_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Service_Type_descriptor();
inline const ::std::string& Service_Type_Name(Service_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Service_Type_descriptor(), value);
}
inline bool Service_Type_Parse(
    const ::std::string& name, Service_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Service_Type>(
    Service_Type_descriptor(), name, value);
}
enum Error_Type {
  Error_Type_OK = 0,
  Error_Type_INVALID_REQUEST = 2
};
bool Error_Type_IsValid(int value);
const Error_Type Error_Type_Type_MIN = Error_Type_OK;
const Error_Type Error_Type_Type_MAX = Error_Type_INVALID_REQUEST;
const int Error_Type_Type_ARRAYSIZE = Error_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Error_Type_descriptor();
inline const ::std::string& Error_Type_Name(Error_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Error_Type_descriptor(), value);
}
inline bool Error_Type_Parse(
    const ::std::string& name, Error_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Error_Type>(
    Error_Type_descriptor(), name, value);
}
// ===================================================================

class Service : public ::google::protobuf::Message {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  Service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Service_Type Type;
  static const Type HELLO = Service_Type_HELLO;
  static const Type PINGPONG = Service_Type_PINGPONG;
  static inline bool Type_IsValid(int value) {
    return Service_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Service_Type_Type_MIN;
  static const Type Type_MAX =
    Service_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Service_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Service_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Service_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Service_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:comm.Service)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Error_Type Type;
  static const Type OK = Error_Type_OK;
  static const Type INVALID_REQUEST = Error_Type_INVALID_REQUEST;
  static inline bool Type_IsValid(int value) {
    return Error_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Error_Type_Type_MIN;
  static const Type Type_MAX =
    Error_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Error_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Error_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Error_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Error_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:comm.Error)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class HelloRequest : public ::google::protobuf::Message {
 public:
  HelloRequest();
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloRequest& default_instance();

  void Swap(HelloRequest* other);

  // implements Message ----------------------------------------------

  HelloRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:comm.HelloRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static HelloRequest* default_instance_;
};
// -------------------------------------------------------------------

class HelloReply : public ::google::protobuf::Message {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloReply& default_instance();

  void Swap(HelloReply* other);

  // implements Message ----------------------------------------------

  HelloReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:comm.HelloReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static HelloReply* default_instance_;
};
// -------------------------------------------------------------------

class PingpongRequest : public ::google::protobuf::Message {
 public:
  PingpongRequest();
  virtual ~PingpongRequest();

  PingpongRequest(const PingpongRequest& from);

  inline PingpongRequest& operator=(const PingpongRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingpongRequest& default_instance();

  void Swap(PingpongRequest* other);

  // implements Message ----------------------------------------------

  PingpongRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingpongRequest& from);
  void MergeFrom(const PingpongRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:comm.PingpongRequest)
 private:
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static PingpongRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingpongReply : public ::google::protobuf::Message {
 public:
  PingpongReply();
  virtual ~PingpongReply();

  PingpongReply(const PingpongReply& from);

  inline PingpongReply& operator=(const PingpongReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingpongReply& default_instance();

  void Swap(PingpongReply* other);

  // implements Message ----------------------------------------------

  PingpongReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingpongReply& from);
  void MergeFrom(const PingpongReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:comm.PingpongReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static PingpongReply* default_instance_;
};
// -------------------------------------------------------------------

class SigninRequest : public ::google::protobuf::Message {
 public:
  SigninRequest();
  virtual ~SigninRequest();

  SigninRequest(const SigninRequest& from);

  inline SigninRequest& operator=(const SigninRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SigninRequest& default_instance();

  void Swap(SigninRequest* other);

  // implements Message ----------------------------------------------

  SigninRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SigninRequest& from);
  void MergeFrom(const SigninRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:comm.SigninRequest)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static SigninRequest* default_instance_;
};
// -------------------------------------------------------------------

class SigninReply : public ::google::protobuf::Message {
 public:
  SigninReply();
  virtual ~SigninReply();

  SigninReply(const SigninReply& from);

  inline SigninReply& operator=(const SigninReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SigninReply& default_instance();

  void Swap(SigninReply* other);

  // implements Message ----------------------------------------------

  SigninReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SigninReply& from);
  void MergeFrom(const SigninReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required bytes auth = 2;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 2;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const void* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // @@protoc_insertion_point(class_scope:comm.SigninReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_auth();
  inline void clear_has_auth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auth_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static SigninReply* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionRequest : public ::google::protobuf::Message {
 public:
  CreateSessionRequest();
  virtual ~CreateSessionRequest();

  CreateSessionRequest(const CreateSessionRequest& from);

  inline CreateSessionRequest& operator=(const CreateSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionRequest& default_instance();

  void Swap(CreateSessionRequest* other);

  // implements Message ----------------------------------------------

  CreateSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionRequest& from);
  void MergeFrom(const CreateSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes auth = 1;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 1;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const void* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:comm.CreateSessionRequest)
 private:
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auth_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionReply : public ::google::protobuf::Message {
 public:
  CreateSessionReply();
  virtual ~CreateSessionReply();

  CreateSessionReply(const CreateSessionReply& from);

  inline CreateSessionReply& operator=(const CreateSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionReply& default_instance();

  void Swap(CreateSessionReply* other);

  // implements Message ----------------------------------------------

  CreateSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionReply& from);
  void MergeFrom(const CreateSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required bytes sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const void* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // required string host = 3;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 3;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required uint32 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:comm.CreateSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 port_;
  ::std::string* host_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionRequest : public ::google::protobuf::Message {
 public:
  JoinSessionRequest();
  virtual ~JoinSessionRequest();

  JoinSessionRequest(const JoinSessionRequest& from);

  inline JoinSessionRequest& operator=(const JoinSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionRequest& default_instance();

  void Swap(JoinSessionRequest* other);

  // implements Message ----------------------------------------------

  JoinSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionRequest& from);
  void MergeFrom(const JoinSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes auth = 1;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 1;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const void* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // required bytes sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const void* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  inline void set_allocated_sid(::std::string* sid);

  // @@protoc_insertion_point(class_scope:comm.JoinSessionRequest)
 private:
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auth_;
  ::std::string* sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionReply_Player : public ::google::protobuf::Message {
 public:
  JoinSessionReply_Player();
  virtual ~JoinSessionReply_Player();

  JoinSessionReply_Player(const JoinSessionReply_Player& from);

  inline JoinSessionReply_Player& operator=(const JoinSessionReply_Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionReply_Player& default_instance();

  void Swap(JoinSessionReply_Player* other);

  // implements Message ----------------------------------------------

  JoinSessionReply_Player* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionReply_Player& from);
  void MergeFrom(const JoinSessionReply_Player& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string avatar = 3;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 3;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // @@protoc_insertion_point(class_scope:comm.JoinSessionReply.Player)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_avatar();
  inline void clear_has_avatar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* avatar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionReply_Player* default_instance_;
};
// -------------------------------------------------------------------

class JoinSessionReply : public ::google::protobuf::Message {
 public:
  JoinSessionReply();
  virtual ~JoinSessionReply();

  JoinSessionReply(const JoinSessionReply& from);

  inline JoinSessionReply& operator=(const JoinSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinSessionReply& default_instance();

  void Swap(JoinSessionReply* other);

  // implements Message ----------------------------------------------

  JoinSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinSessionReply& from);
  void MergeFrom(const JoinSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JoinSessionReply_Player Player;

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated group Player = 2 {
  inline int player_size() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 2;
  inline const ::comm::JoinSessionReply_Player& player(int index) const;
  inline ::comm::JoinSessionReply_Player* mutable_player(int index);
  inline ::comm::JoinSessionReply_Player* add_player();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >&
      player() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >*
      mutable_player();

  // @@protoc_insertion_point(class_scope:comm.JoinSessionReply)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player > player_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JoinSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionRequest : public ::google::protobuf::Message {
 public:
  ListSessionRequest();
  virtual ~ListSessionRequest();

  ListSessionRequest(const ListSessionRequest& from);

  inline ListSessionRequest& operator=(const ListSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionRequest& default_instance();

  void Swap(ListSessionRequest* other);

  // implements Message ----------------------------------------------

  ListSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionRequest& from);
  void MergeFrom(const ListSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes auth = 1;
  inline bool has_auth() const;
  inline void clear_auth();
  static const int kAuthFieldNumber = 1;
  inline const ::std::string& auth() const;
  inline void set_auth(const ::std::string& value);
  inline void set_auth(const char* value);
  inline void set_auth(const void* value, size_t size);
  inline ::std::string* mutable_auth();
  inline ::std::string* release_auth();
  inline void set_allocated_auth(::std::string* auth);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:comm.ListSessionRequest)
 private:
  inline void set_has_auth();
  inline void clear_has_auth();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auth_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionReply_Session : public ::google::protobuf::Message {
 public:
  ListSessionReply_Session();
  virtual ~ListSessionReply_Session();

  ListSessionReply_Session(const ListSessionReply_Session& from);

  inline ListSessionReply_Session& operator=(const ListSessionReply_Session& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionReply_Session& default_instance();

  void Swap(ListSessionReply_Session* other);

  // implements Message ----------------------------------------------

  ListSessionReply_Session* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionReply_Session& from);
  void MergeFrom(const ListSessionReply_Session& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string host = 2;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 2;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // required uint32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // required uint32 player_count = 4;
  inline bool has_player_count() const;
  inline void clear_player_count();
  static const int kPlayerCountFieldNumber = 4;
  inline ::google::protobuf::uint32 player_count() const;
  inline void set_player_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:comm.ListSessionReply.Session)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_player_count();
  inline void clear_has_player_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* host_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 player_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionReply_Session* default_instance_;
};
// -------------------------------------------------------------------

class ListSessionReply : public ::google::protobuf::Message {
 public:
  ListSessionReply();
  virtual ~ListSessionReply();

  ListSessionReply(const ListSessionReply& from);

  inline ListSessionReply& operator=(const ListSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSessionReply& default_instance();

  void Swap(ListSessionReply* other);

  // implements Message ----------------------------------------------

  ListSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSessionReply& from);
  void MergeFrom(const ListSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ListSessionReply_Session Session;

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // repeated group Session = 2 {
  inline int session_size() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::comm::ListSessionReply_Session& session(int index) const;
  inline ::comm::ListSessionReply_Session* mutable_session(int index);
  inline ::comm::ListSessionReply_Session* add_session();
  inline const ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >&
      session() const;
  inline ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >*
      mutable_session();

  // @@protoc_insertion_point(class_scope:comm.ListSessionReply)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session > session_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static ListSessionReply* default_instance_;
};
// -------------------------------------------------------------------

class LeaveSessionRequest : public ::google::protobuf::Message {
 public:
  LeaveSessionRequest();
  virtual ~LeaveSessionRequest();

  LeaveSessionRequest(const LeaveSessionRequest& from);

  inline LeaveSessionRequest& operator=(const LeaveSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveSessionRequest& default_instance();

  void Swap(LeaveSessionRequest* other);

  // implements Message ----------------------------------------------

  LeaveSessionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveSessionRequest& from);
  void MergeFrom(const LeaveSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:comm.LeaveSessionRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaveSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class LeaveSessionReply : public ::google::protobuf::Message {
 public:
  LeaveSessionReply();
  virtual ~LeaveSessionReply();

  LeaveSessionReply(const LeaveSessionReply& from);

  inline LeaveSessionReply& operator=(const LeaveSessionReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveSessionReply& default_instance();

  void Swap(LeaveSessionReply* other);

  // implements Message ----------------------------------------------

  LeaveSessionReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveSessionReply& from);
  void MergeFrom(const LeaveSessionReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:comm.LeaveSessionReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaveSessionReply* default_instance_;
};
// ===================================================================


// ===================================================================

// Service

// -------------------------------------------------------------------

// Error

// -------------------------------------------------------------------

// HelloRequest

// required string name = 1;
inline bool HelloRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& HelloRequest::name() const {
  return *name_;
}
inline void HelloRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HelloRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void HelloRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* HelloRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HelloReply

// required uint32 type = 1;
inline bool HelloReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 HelloReply::type() const {
  return type_;
}
inline void HelloReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string text = 2;
inline bool HelloReply::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HelloReply::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HelloReply::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HelloReply::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& HelloReply::text() const {
  return *text_;
}
inline void HelloReply::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void HelloReply::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void HelloReply::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HelloReply::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* HelloReply::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HelloReply::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PingpongRequest

// required string text = 1;
inline bool PingpongRequest::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingpongRequest::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingpongRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingpongRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& PingpongRequest::text() const {
  return *text_;
}
inline void PingpongRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void PingpongRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void PingpongRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingpongRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* PingpongRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PingpongRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PingpongReply

// required uint32 type = 1;
inline bool PingpongReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingpongReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingpongReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingpongReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 PingpongReply::type() const {
  return type_;
}
inline void PingpongReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required string text = 2;
inline bool PingpongReply::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingpongReply::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingpongReply::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingpongReply::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& PingpongReply::text() const {
  return *text_;
}
inline void PingpongReply::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void PingpongReply::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void PingpongReply::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingpongReply::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* PingpongReply::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PingpongReply::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SigninRequest

// required string uid = 1;
inline bool SigninRequest::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninRequest::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninRequest::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninRequest::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& SigninRequest::uid() const {
  return *uid_;
}
inline void SigninRequest::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SigninRequest::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void SigninRequest::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninRequest::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* SigninRequest::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninRequest::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool SigninRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninRequest::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SigninRequest::password() const {
  return *password_;
}
inline void SigninRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SigninRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void SigninRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* SigninRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SigninReply

// required uint32 type = 1;
inline bool SigninReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SigninReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SigninReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SigninReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SigninReply::type() const {
  return type_;
}
inline void SigninReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required bytes auth = 2;
inline bool SigninReply::has_auth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SigninReply::set_has_auth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SigninReply::clear_has_auth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SigninReply::clear_auth() {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& SigninReply::auth() const {
  return *auth_;
}
inline void SigninReply::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void SigninReply::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void SigninReply::set_auth(const void* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SigninReply::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  return auth_;
}
inline ::std::string* SigninReply::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SigninReply::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateSessionRequest

// required bytes auth = 1;
inline bool CreateSessionRequest::has_auth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionRequest::set_has_auth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionRequest::clear_has_auth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionRequest::clear_auth() {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& CreateSessionRequest::auth() const {
  return *auth_;
}
inline void CreateSessionRequest::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void CreateSessionRequest::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void CreateSessionRequest::set_auth(const void* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionRequest::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  return auth_;
}
inline ::std::string* CreateSessionRequest::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionRequest::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool CreateSessionRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateSessionRequest::name() const {
  return *name_;
}
inline void CreateSessionRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateSessionRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateSessionRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateSessionRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateSessionReply

// required uint32 type = 1;
inline bool CreateSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CreateSessionReply::type() const {
  return type_;
}
inline void CreateSessionReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required bytes sid = 2;
inline bool CreateSessionReply::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionReply::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionReply::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionReply::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& CreateSessionReply::sid() const {
  return *sid_;
}
inline void CreateSessionReply::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void CreateSessionReply::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void CreateSessionReply::set_sid(const void* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionReply::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* CreateSessionReply::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionReply::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string host = 3;
inline bool CreateSessionReply::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSessionReply::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSessionReply::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSessionReply::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& CreateSessionReply::host() const {
  return *host_;
}
inline void CreateSessionReply::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CreateSessionReply::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void CreateSessionReply::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateSessionReply::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* CreateSessionReply::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateSessionReply::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 port = 4;
inline bool CreateSessionReply::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSessionReply::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSessionReply::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSessionReply::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 CreateSessionReply::port() const {
  return port_;
}
inline void CreateSessionReply::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// JoinSessionRequest

// required bytes auth = 1;
inline bool JoinSessionRequest::has_auth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionRequest::set_has_auth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionRequest::clear_has_auth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionRequest::clear_auth() {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& JoinSessionRequest::auth() const {
  return *auth_;
}
inline void JoinSessionRequest::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void JoinSessionRequest::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void JoinSessionRequest::set_auth(const void* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionRequest::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  return auth_;
}
inline ::std::string* JoinSessionRequest::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionRequest::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes sid = 2;
inline bool JoinSessionRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinSessionRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinSessionRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinSessionRequest::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& JoinSessionRequest::sid() const {
  return *sid_;
}
inline void JoinSessionRequest::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void JoinSessionRequest::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void JoinSessionRequest::set_sid(const void* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionRequest::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* JoinSessionRequest::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionRequest::set_allocated_sid(::std::string* sid) {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    delete sid_;
  }
  if (sid) {
    set_has_sid();
    sid_ = sid;
  } else {
    clear_has_sid();
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// JoinSessionReply_Player

// required bytes uid = 1;
inline bool JoinSessionReply_Player::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionReply_Player::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionReply_Player::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionReply_Player::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& JoinSessionReply_Player::uid() const {
  return *uid_;
}
inline void JoinSessionReply_Player::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void JoinSessionReply_Player::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void JoinSessionReply_Player::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* JoinSessionReply_Player::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 2;
inline bool JoinSessionReply_Player::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinSessionReply_Player::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinSessionReply_Player::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinSessionReply_Player::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JoinSessionReply_Player::name() const {
  return *name_;
}
inline void JoinSessionReply_Player::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply_Player::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply_Player::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* JoinSessionReply_Player::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string avatar = 3;
inline bool JoinSessionReply_Player::has_avatar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinSessionReply_Player::set_has_avatar() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinSessionReply_Player::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinSessionReply_Player::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& JoinSessionReply_Player::avatar() const {
  return *avatar_;
}
inline void JoinSessionReply_Player::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void JoinSessionReply_Player::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void JoinSessionReply_Player::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply_Player::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* JoinSessionReply_Player::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply_Player::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// JoinSessionReply

// required string name = 1;
inline bool JoinSessionReply::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinSessionReply::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinSessionReply::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinSessionReply::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JoinSessionReply::name() const {
  return *name_;
}
inline void JoinSessionReply::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinSessionReply::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinSessionReply::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* JoinSessionReply::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinSessionReply::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated group Player = 2 {
inline int JoinSessionReply::player_size() const {
  return player_.size();
}
inline void JoinSessionReply::clear_player() {
  player_.Clear();
}
inline const ::comm::JoinSessionReply_Player& JoinSessionReply::player(int index) const {
  return player_.Get(index);
}
inline ::comm::JoinSessionReply_Player* JoinSessionReply::mutable_player(int index) {
  return player_.Mutable(index);
}
inline ::comm::JoinSessionReply_Player* JoinSessionReply::add_player() {
  return player_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >&
JoinSessionReply::player() const {
  return player_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::JoinSessionReply_Player >*
JoinSessionReply::mutable_player() {
  return &player_;
}

// -------------------------------------------------------------------

// ListSessionRequest

// required bytes auth = 1;
inline bool ListSessionRequest::has_auth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionRequest::set_has_auth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionRequest::clear_has_auth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionRequest::clear_auth() {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    auth_->clear();
  }
  clear_has_auth();
}
inline const ::std::string& ListSessionRequest::auth() const {
  return *auth_;
}
inline void ListSessionRequest::set_auth(const ::std::string& value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void ListSessionRequest::set_auth(const char* value) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(value);
}
inline void ListSessionRequest::set_auth(const void* value, size_t size) {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  auth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionRequest::mutable_auth() {
  set_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    auth_ = new ::std::string;
  }
  return auth_;
}
inline ::std::string* ListSessionRequest::release_auth() {
  clear_has_auth();
  if (auth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_;
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionRequest::set_allocated_auth(::std::string* auth) {
  if (auth_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_;
  }
  if (auth) {
    set_has_auth();
    auth_ = auth;
  } else {
    clear_has_auth();
    auth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 count = 2;
inline bool ListSessionRequest::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSessionRequest::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSessionRequest::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSessionRequest::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ListSessionRequest::count() const {
  return count_;
}
inline void ListSessionRequest::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ListSessionReply_Session

// required string name = 1;
inline bool ListSessionReply_Session::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionReply_Session::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionReply_Session::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionReply_Session::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ListSessionReply_Session::name() const {
  return *name_;
}
inline void ListSessionReply_Session::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ListSessionReply_Session::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ListSessionReply_Session::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionReply_Session::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ListSessionReply_Session::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionReply_Session::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string host = 2;
inline bool ListSessionReply_Session::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListSessionReply_Session::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListSessionReply_Session::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListSessionReply_Session::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& ListSessionReply_Session::host() const {
  return *host_;
}
inline void ListSessionReply_Session::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ListSessionReply_Session::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void ListSessionReply_Session::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListSessionReply_Session::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* ListSessionReply_Session::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListSessionReply_Session::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 port = 3;
inline bool ListSessionReply_Session::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListSessionReply_Session::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListSessionReply_Session::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListSessionReply_Session::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ListSessionReply_Session::port() const {
  return port_;
}
inline void ListSessionReply_Session::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// required uint32 player_count = 4;
inline bool ListSessionReply_Session::has_player_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListSessionReply_Session::set_has_player_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListSessionReply_Session::clear_has_player_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListSessionReply_Session::clear_player_count() {
  player_count_ = 0u;
  clear_has_player_count();
}
inline ::google::protobuf::uint32 ListSessionReply_Session::player_count() const {
  return player_count_;
}
inline void ListSessionReply_Session::set_player_count(::google::protobuf::uint32 value) {
  set_has_player_count();
  player_count_ = value;
}

// -------------------------------------------------------------------

// ListSessionReply

// required uint32 type = 1;
inline bool ListSessionReply::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListSessionReply::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListSessionReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListSessionReply::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ListSessionReply::type() const {
  return type_;
}
inline void ListSessionReply::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated group Session = 2 {
inline int ListSessionReply::session_size() const {
  return session_.size();
}
inline void ListSessionReply::clear_session() {
  session_.Clear();
}
inline const ::comm::ListSessionReply_Session& ListSessionReply::session(int index) const {
  return session_.Get(index);
}
inline ::comm::ListSessionReply_Session* ListSessionReply::mutable_session(int index) {
  return session_.Mutable(index);
}
inline ::comm::ListSessionReply_Session* ListSessionReply::add_session() {
  return session_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >&
ListSessionReply::session() const {
  return session_;
}
inline ::google::protobuf::RepeatedPtrField< ::comm::ListSessionReply_Session >*
ListSessionReply::mutable_session() {
  return &session_;
}

// -------------------------------------------------------------------

// LeaveSessionRequest

// -------------------------------------------------------------------

// LeaveSessionReply


// @@protoc_insertion_point(namespace_scope)

}  // namespace comm

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comm::Service_Type>() {
  return ::comm::Service_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::comm::Error_Type>() {
  return ::comm::Error_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
