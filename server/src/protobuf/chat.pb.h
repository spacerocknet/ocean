// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef PROTOBUF_chat_2eproto__INCLUDED
#define PROTOBUF_chat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "model.pb.h"
#include "type.pb.h"
// @@protoc_insertion_point(includes)

namespace chat {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_chat_2eproto();
void protobuf_AssignDesc_chat_2eproto();
void protobuf_ShutdownFile_chat_2eproto();

class User;
class Notification;
class Chat;
class GroupChat;
class Message;
class HasChat;

enum User_State {
  User_State_REGISTED = 1,
  User_State_ACTIVE = 2,
  User_State_DELETED = 3
};
bool User_State_IsValid(int value);
const User_State User_State_State_MIN = User_State_REGISTED;
const User_State User_State_State_MAX = User_State_DELETED;
const int User_State_State_ARRAYSIZE = User_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* User_State_descriptor();
inline const ::std::string& User_State_Name(User_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    User_State_descriptor(), value);
}
inline bool User_State_Parse(
    const ::std::string& name, User_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<User_State>(
    User_State_descriptor(), name, value);
}
enum Notification_Type {
  Notification_Type_FRIEND_REQUEST = 0
};
bool Notification_Type_IsValid(int value);
const Notification_Type Notification_Type_Type_MIN = Notification_Type_FRIEND_REQUEST;
const Notification_Type Notification_Type_Type_MAX = Notification_Type_FRIEND_REQUEST;
const int Notification_Type_Type_ARRAYSIZE = Notification_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Notification_Type_descriptor();
inline const ::std::string& Notification_Type_Name(Notification_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Notification_Type_descriptor(), value);
}
inline bool Notification_Type_Parse(
    const ::std::string& name, Notification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Notification_Type>(
    Notification_Type_descriptor(), name, value);
}
// ===================================================================

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef User_State State;
  static const State REGISTED = User_State_REGISTED;
  static const State ACTIVE = User_State_ACTIVE;
  static const State DELETED = User_State_DELETED;
  static inline bool State_IsValid(int value) {
    return User_State_IsValid(value);
  }
  static const State State_MIN =
    User_State_State_MIN;
  static const State State_MAX =
    User_State_State_MAX;
  static const int State_ARRAYSIZE =
    User_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return User_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return User_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return User_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string tel = 1;
  inline bool has_tel() const;
  inline void clear_tel();
  static const int kTelFieldNumber = 1;
  inline const ::std::string& tel() const;
  inline void set_tel(const ::std::string& value);
  inline void set_tel(const char* value);
  inline void set_tel(const char* value, size_t size);
  inline ::std::string* mutable_tel();
  inline ::std::string* release_tel();
  inline void set_allocated_tel(::std::string* tel);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string dob = 5;
  inline bool has_dob() const;
  inline void clear_dob();
  static const int kDobFieldNumber = 5;
  inline const ::std::string& dob() const;
  inline void set_dob(const ::std::string& value);
  inline void set_dob(const char* value);
  inline void set_dob(const char* value, size_t size);
  inline ::std::string* mutable_dob();
  inline ::std::string* release_dob();
  inline void set_allocated_dob(::std::string* dob);

  // optional string avatar = 6;
  inline bool has_avatar() const;
  inline void clear_avatar();
  static const int kAvatarFieldNumber = 6;
  inline const ::std::string& avatar() const;
  inline void set_avatar(const ::std::string& value);
  inline void set_avatar(const char* value);
  inline void set_avatar(const char* value, size_t size);
  inline ::std::string* mutable_avatar();
  inline ::std::string* release_avatar();
  inline void set_allocated_avatar(::std::string* avatar);

  // required uint32 state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  static const int kUSERFieldNumber = 4;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Entity,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::User >, 11, false >
    USER;
  // @@protoc_insertion_point(class_scope:chat.User)
 private:
  inline void set_has_tel();
  inline void clear_has_tel();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_dob();
  inline void clear_has_dob();
  inline void set_has_avatar();
  inline void clear_has_avatar();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tel_;
  ::std::string* password_;
  ::std::string* name_;
  ::std::string* email_;
  ::std::string* dob_;
  ::std::string* avatar_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  Notification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Notification_Type Type;
  static const Type FRIEND_REQUEST = Notification_Type_FRIEND_REQUEST;
  static inline bool Type_IsValid(int value) {
    return Notification_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Notification_Type_Type_MIN;
  static const Type Type_MAX =
    Notification_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Notification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Notification_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Notification_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Notification_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required bool read = 2;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 2;
  inline bool read() const;
  inline void set_read(bool value);

  // optional bytes ref1 = 3;
  inline bool has_ref1() const;
  inline void clear_ref1();
  static const int kRef1FieldNumber = 3;
  inline const ::std::string& ref1() const;
  inline void set_ref1(const ::std::string& value);
  inline void set_ref1(const char* value);
  inline void set_ref1(const void* value, size_t size);
  inline ::std::string* mutable_ref1();
  inline ::std::string* release_ref1();
  inline void set_allocated_ref1(::std::string* ref1);

  // optional bytes ref2 = 4;
  inline bool has_ref2() const;
  inline void clear_ref2();
  static const int kRef2FieldNumber = 4;
  inline const ::std::string& ref2() const;
  inline void set_ref2(const ::std::string& value);
  inline void set_ref2(const char* value);
  inline void set_ref2(const void* value, size_t size);
  inline ::std::string* mutable_ref2();
  inline ::std::string* release_ref2();
  inline void set_allocated_ref2(::std::string* ref2);

  static const int kNOTIFICATIONFieldNumber = 5;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Entity,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::Notification >, 11, false >
    NOTIFICATION;
  // @@protoc_insertion_point(class_scope:chat.Notification)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_ref1();
  inline void clear_has_ref1();
  inline void set_has_ref2();
  inline void clear_has_ref2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  bool read_;
  ::std::string* ref1_;
  ::std::string* ref2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static Notification* default_instance_;
};
// -------------------------------------------------------------------

class Chat : public ::google::protobuf::Message {
 public:
  Chat();
  virtual ~Chat();

  Chat(const Chat& from);

  inline Chat& operator=(const Chat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Chat& default_instance();

  void Swap(Chat* other);

  // implements Message ----------------------------------------------

  Chat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chat& from);
  void MergeFrom(const Chat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required bytes user1 = 2;
  inline bool has_user1() const;
  inline void clear_user1();
  static const int kUser1FieldNumber = 2;
  inline const ::std::string& user1() const;
  inline void set_user1(const ::std::string& value);
  inline void set_user1(const char* value);
  inline void set_user1(const void* value, size_t size);
  inline ::std::string* mutable_user1();
  inline ::std::string* release_user1();
  inline void set_allocated_user1(::std::string* user1);

  // required bytes user2 = 3;
  inline bool has_user2() const;
  inline void clear_user2();
  static const int kUser2FieldNumber = 3;
  inline const ::std::string& user2() const;
  inline void set_user2(const ::std::string& value);
  inline void set_user2(const char* value);
  inline void set_user2(const void* value, size_t size);
  inline ::std::string* mutable_user2();
  inline ::std::string* release_user2();
  inline void set_allocated_user2(::std::string* user2);

  // required uint64 last_active = 4;
  inline bool has_last_active() const;
  inline void clear_last_active();
  static const int kLastActiveFieldNumber = 4;
  inline ::google::protobuf::uint64 last_active() const;
  inline void set_last_active(::google::protobuf::uint64 value);

  static const int kCHATFieldNumber = 6;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Entity,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::Chat >, 11, false >
    CHAT;
  // @@protoc_insertion_point(class_scope:chat.Chat)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_user1();
  inline void clear_has_user1();
  inline void set_has_user2();
  inline void clear_has_user2();
  inline void set_has_last_active();
  inline void clear_has_last_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* topic_;
  ::std::string* user1_;
  ::std::string* user2_;
  ::google::protobuf::uint64 last_active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static Chat* default_instance_;
};
// -------------------------------------------------------------------

class GroupChat : public ::google::protobuf::Message {
 public:
  GroupChat();
  virtual ~GroupChat();

  GroupChat(const GroupChat& from);

  inline GroupChat& operator=(const GroupChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupChat& default_instance();

  void Swap(GroupChat* other);

  // implements Message ----------------------------------------------

  GroupChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupChat& from);
  void MergeFrom(const GroupChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // required uint64 last_active = 4;
  inline bool has_last_active() const;
  inline void clear_last_active();
  static const int kLastActiveFieldNumber = 4;
  inline ::google::protobuf::uint64 last_active() const;
  inline void set_last_active(::google::protobuf::uint64 value);

  static const int kGROUPCHATFieldNumber = 7;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Entity,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::GroupChat >, 11, false >
    GROUP_CHAT;
  // @@protoc_insertion_point(class_scope:chat.GroupChat)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();
  inline void set_has_last_active();
  inline void clear_has_last_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* topic_;
  ::google::protobuf::uint64 last_active_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static GroupChat* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const void* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  static const int kMESSAGEFieldNumber = 8;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Entity,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::Message >, 11, false >
    MESSAGE;
  // @@protoc_insertion_point(class_scope:chat.Message)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* text_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class HasChat : public ::google::protobuf::Message {
 public:
  HasChat();
  virtual ~HasChat();

  HasChat(const HasChat& from);

  inline HasChat& operator=(const HasChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HasChat& default_instance();

  void Swap(HasChat* other);

  // implements Message ----------------------------------------------

  HasChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HasChat& from);
  void MergeFrom(const HasChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 unseen = 1;
  inline bool has_unseen() const;
  inline void clear_unseen();
  static const int kUnseenFieldNumber = 1;
  inline ::google::protobuf::uint32 unseen() const;
  inline void set_unseen(::google::protobuf::uint32 value);

  // required uint64 last_seen = 2;
  inline bool has_last_seen() const;
  inline void clear_last_seen();
  static const int kLastSeenFieldNumber = 2;
  inline ::google::protobuf::uint64 last_seen() const;
  inline void set_last_seen(::google::protobuf::uint64 value);

  static const int kHASCHATFieldNumber = 6;
  static ::google::protobuf::internal::ExtensionIdentifier< ::model::Relation,
      ::google::protobuf::internal::MessageTypeTraits< ::chat::HasChat >, 11, false >
    HAS_CHAT;
  // @@protoc_insertion_point(class_scope:chat.HasChat)
 private:
  inline void set_has_unseen();
  inline void clear_has_unseen();
  inline void set_has_last_seen();
  inline void clear_has_last_seen();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 last_seen_;
  ::google::protobuf::uint32 unseen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_chat_2eproto();
  friend void protobuf_AssignDesc_chat_2eproto();
  friend void protobuf_ShutdownFile_chat_2eproto();

  void InitAsDefaultInstance();
  static HasChat* default_instance_;
};
// ===================================================================


// ===================================================================

// User

// required string tel = 1;
inline bool User::has_tel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_tel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_tel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_tel() {
  if (tel_ != &::google::protobuf::internal::kEmptyString) {
    tel_->clear();
  }
  clear_has_tel();
}
inline const ::std::string& User::tel() const {
  return *tel_;
}
inline void User::set_tel(const ::std::string& value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void User::set_tel(const char* value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void User::set_tel(const char* value, size_t size) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_tel() {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  return tel_;
}
inline ::std::string* User::release_tel() {
  clear_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tel_;
    tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_tel(::std::string* tel) {
  if (tel_ != &::google::protobuf::internal::kEmptyString) {
    delete tel_;
  }
  if (tel) {
    set_has_tel();
    tel_ = tel;
  } else {
    clear_has_tel();
    tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool User::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& User::password() const {
  return *password_;
}
inline void User::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void User::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* User::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& User::name() const {
  return *name_;
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 4;
inline bool User::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& User::email() const {
  return *email_;
}
inline void User::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void User::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void User::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* User::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dob = 5;
inline bool User::has_dob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void User::set_has_dob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void User::clear_has_dob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void User::clear_dob() {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    dob_->clear();
  }
  clear_has_dob();
}
inline const ::std::string& User::dob() const {
  return *dob_;
}
inline void User::set_dob(const ::std::string& value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void User::set_dob(const char* value) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(value);
}
inline void User::set_dob(const char* value, size_t size) {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  dob_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_dob() {
  set_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    dob_ = new ::std::string;
  }
  return dob_;
}
inline ::std::string* User::release_dob() {
  clear_has_dob();
  if (dob_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dob_;
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_dob(::std::string* dob) {
  if (dob_ != &::google::protobuf::internal::kEmptyString) {
    delete dob_;
  }
  if (dob) {
    set_has_dob();
    dob_ = dob;
  } else {
    clear_has_dob();
    dob_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string avatar = 6;
inline bool User::has_avatar() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_avatar() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_avatar() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_avatar() {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    avatar_->clear();
  }
  clear_has_avatar();
}
inline const ::std::string& User::avatar() const {
  return *avatar_;
}
inline void User::set_avatar(const ::std::string& value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void User::set_avatar(const char* value) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(value);
}
inline void User::set_avatar(const char* value, size_t size) {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  avatar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_avatar() {
  set_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    avatar_ = new ::std::string;
  }
  return avatar_;
}
inline ::std::string* User::release_avatar() {
  clear_has_avatar();
  if (avatar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = avatar_;
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_avatar(::std::string* avatar) {
  if (avatar_ != &::google::protobuf::internal::kEmptyString) {
    delete avatar_;
  }
  if (avatar) {
    set_has_avatar();
    avatar_ = avatar;
  } else {
    clear_has_avatar();
    avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 state = 7;
inline bool User::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void User::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void User::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void User::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 User::state() const {
  return state_;
}
inline void User::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// Notification

// required uint32 type = 1;
inline bool Notification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Notification::type() const {
  return type_;
}
inline void Notification::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required bool read = 2;
inline bool Notification::has_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Notification::set_has_read() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Notification::clear_has_read() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Notification::clear_read() {
  read_ = false;
  clear_has_read();
}
inline bool Notification::read() const {
  return read_;
}
inline void Notification::set_read(bool value) {
  set_has_read();
  read_ = value;
}

// optional bytes ref1 = 3;
inline bool Notification::has_ref1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Notification::set_has_ref1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Notification::clear_has_ref1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Notification::clear_ref1() {
  if (ref1_ != &::google::protobuf::internal::kEmptyString) {
    ref1_->clear();
  }
  clear_has_ref1();
}
inline const ::std::string& Notification::ref1() const {
  return *ref1_;
}
inline void Notification::set_ref1(const ::std::string& value) {
  set_has_ref1();
  if (ref1_ == &::google::protobuf::internal::kEmptyString) {
    ref1_ = new ::std::string;
  }
  ref1_->assign(value);
}
inline void Notification::set_ref1(const char* value) {
  set_has_ref1();
  if (ref1_ == &::google::protobuf::internal::kEmptyString) {
    ref1_ = new ::std::string;
  }
  ref1_->assign(value);
}
inline void Notification::set_ref1(const void* value, size_t size) {
  set_has_ref1();
  if (ref1_ == &::google::protobuf::internal::kEmptyString) {
    ref1_ = new ::std::string;
  }
  ref1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_ref1() {
  set_has_ref1();
  if (ref1_ == &::google::protobuf::internal::kEmptyString) {
    ref1_ = new ::std::string;
  }
  return ref1_;
}
inline ::std::string* Notification::release_ref1() {
  clear_has_ref1();
  if (ref1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref1_;
    ref1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_ref1(::std::string* ref1) {
  if (ref1_ != &::google::protobuf::internal::kEmptyString) {
    delete ref1_;
  }
  if (ref1) {
    set_has_ref1();
    ref1_ = ref1;
  } else {
    clear_has_ref1();
    ref1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ref2 = 4;
inline bool Notification::has_ref2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Notification::set_has_ref2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Notification::clear_has_ref2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Notification::clear_ref2() {
  if (ref2_ != &::google::protobuf::internal::kEmptyString) {
    ref2_->clear();
  }
  clear_has_ref2();
}
inline const ::std::string& Notification::ref2() const {
  return *ref2_;
}
inline void Notification::set_ref2(const ::std::string& value) {
  set_has_ref2();
  if (ref2_ == &::google::protobuf::internal::kEmptyString) {
    ref2_ = new ::std::string;
  }
  ref2_->assign(value);
}
inline void Notification::set_ref2(const char* value) {
  set_has_ref2();
  if (ref2_ == &::google::protobuf::internal::kEmptyString) {
    ref2_ = new ::std::string;
  }
  ref2_->assign(value);
}
inline void Notification::set_ref2(const void* value, size_t size) {
  set_has_ref2();
  if (ref2_ == &::google::protobuf::internal::kEmptyString) {
    ref2_ = new ::std::string;
  }
  ref2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Notification::mutable_ref2() {
  set_has_ref2();
  if (ref2_ == &::google::protobuf::internal::kEmptyString) {
    ref2_ = new ::std::string;
  }
  return ref2_;
}
inline ::std::string* Notification::release_ref2() {
  clear_has_ref2();
  if (ref2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref2_;
    ref2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Notification::set_allocated_ref2(::std::string* ref2) {
  if (ref2_ != &::google::protobuf::internal::kEmptyString) {
    delete ref2_;
  }
  if (ref2) {
    set_has_ref2();
    ref2_ = ref2;
  } else {
    clear_has_ref2();
    ref2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Chat

// optional string topic = 1;
inline bool Chat::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Chat::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Chat::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Chat::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& Chat::topic() const {
  return *topic_;
}
inline void Chat::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Chat::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void Chat::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* Chat::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chat::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes user1 = 2;
inline bool Chat::has_user1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Chat::set_has_user1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Chat::clear_has_user1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Chat::clear_user1() {
  if (user1_ != &::google::protobuf::internal::kEmptyString) {
    user1_->clear();
  }
  clear_has_user1();
}
inline const ::std::string& Chat::user1() const {
  return *user1_;
}
inline void Chat::set_user1(const ::std::string& value) {
  set_has_user1();
  if (user1_ == &::google::protobuf::internal::kEmptyString) {
    user1_ = new ::std::string;
  }
  user1_->assign(value);
}
inline void Chat::set_user1(const char* value) {
  set_has_user1();
  if (user1_ == &::google::protobuf::internal::kEmptyString) {
    user1_ = new ::std::string;
  }
  user1_->assign(value);
}
inline void Chat::set_user1(const void* value, size_t size) {
  set_has_user1();
  if (user1_ == &::google::protobuf::internal::kEmptyString) {
    user1_ = new ::std::string;
  }
  user1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::mutable_user1() {
  set_has_user1();
  if (user1_ == &::google::protobuf::internal::kEmptyString) {
    user1_ = new ::std::string;
  }
  return user1_;
}
inline ::std::string* Chat::release_user1() {
  clear_has_user1();
  if (user1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user1_;
    user1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chat::set_allocated_user1(::std::string* user1) {
  if (user1_ != &::google::protobuf::internal::kEmptyString) {
    delete user1_;
  }
  if (user1) {
    set_has_user1();
    user1_ = user1;
  } else {
    clear_has_user1();
    user1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes user2 = 3;
inline bool Chat::has_user2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Chat::set_has_user2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Chat::clear_has_user2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Chat::clear_user2() {
  if (user2_ != &::google::protobuf::internal::kEmptyString) {
    user2_->clear();
  }
  clear_has_user2();
}
inline const ::std::string& Chat::user2() const {
  return *user2_;
}
inline void Chat::set_user2(const ::std::string& value) {
  set_has_user2();
  if (user2_ == &::google::protobuf::internal::kEmptyString) {
    user2_ = new ::std::string;
  }
  user2_->assign(value);
}
inline void Chat::set_user2(const char* value) {
  set_has_user2();
  if (user2_ == &::google::protobuf::internal::kEmptyString) {
    user2_ = new ::std::string;
  }
  user2_->assign(value);
}
inline void Chat::set_user2(const void* value, size_t size) {
  set_has_user2();
  if (user2_ == &::google::protobuf::internal::kEmptyString) {
    user2_ = new ::std::string;
  }
  user2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chat::mutable_user2() {
  set_has_user2();
  if (user2_ == &::google::protobuf::internal::kEmptyString) {
    user2_ = new ::std::string;
  }
  return user2_;
}
inline ::std::string* Chat::release_user2() {
  clear_has_user2();
  if (user2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user2_;
    user2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Chat::set_allocated_user2(::std::string* user2) {
  if (user2_ != &::google::protobuf::internal::kEmptyString) {
    delete user2_;
  }
  if (user2) {
    set_has_user2();
    user2_ = user2;
  } else {
    clear_has_user2();
    user2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 last_active = 4;
inline bool Chat::has_last_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Chat::set_has_last_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Chat::clear_has_last_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Chat::clear_last_active() {
  last_active_ = GOOGLE_ULONGLONG(0);
  clear_has_last_active();
}
inline ::google::protobuf::uint64 Chat::last_active() const {
  return last_active_;
}
inline void Chat::set_last_active(::google::protobuf::uint64 value) {
  set_has_last_active();
  last_active_ = value;
}

// -------------------------------------------------------------------

// GroupChat

// optional string topic = 1;
inline bool GroupChat::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupChat::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupChat::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupChat::clear_topic() {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& GroupChat::topic() const {
  return *topic_;
}
inline void GroupChat::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void GroupChat::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
}
inline void GroupChat::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupChat::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    topic_ = new ::std::string;
  }
  return topic_;
}
inline ::std::string* GroupChat::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupChat::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::kEmptyString) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 last_active = 4;
inline bool GroupChat::has_last_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupChat::set_has_last_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupChat::clear_has_last_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupChat::clear_last_active() {
  last_active_ = GOOGLE_ULONGLONG(0);
  clear_has_last_active();
}
inline ::google::protobuf::uint64 GroupChat::last_active() const {
  return last_active_;
}
inline void GroupChat::set_last_active(::google::protobuf::uint64 value) {
  set_has_last_active();
  last_active_ = value;
}

// -------------------------------------------------------------------

// Message

// required bytes sender = 1;
inline bool Message::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& Message::sender() const {
  return *sender_;
}
inline void Message::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void Message::set_sender(const void* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* Message::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 2;
inline bool Message::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& Message::text() const {
  return *text_;
}
inline void Message::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void Message::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* Message::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 type = 3;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Message::type() const {
  return type_;
}
inline void Message::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// HasChat

// required uint32 unseen = 1;
inline bool HasChat::has_unseen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HasChat::set_has_unseen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HasChat::clear_has_unseen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HasChat::clear_unseen() {
  unseen_ = 0u;
  clear_has_unseen();
}
inline ::google::protobuf::uint32 HasChat::unseen() const {
  return unseen_;
}
inline void HasChat::set_unseen(::google::protobuf::uint32 value) {
  set_has_unseen();
  unseen_ = value;
}

// required uint64 last_seen = 2;
inline bool HasChat::has_last_seen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HasChat::set_has_last_seen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HasChat::clear_has_last_seen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HasChat::clear_last_seen() {
  last_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_last_seen();
}
inline ::google::protobuf::uint64 HasChat::last_seen() const {
  return last_seen_;
}
inline void HasChat::set_last_seen(::google::protobuf::uint64 value) {
  set_has_last_seen();
  last_seen_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::User_State>() {
  return ::chat::User_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chat::Notification_Type>() {
  return ::chat::Notification_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chat_2eproto__INCLUDED
